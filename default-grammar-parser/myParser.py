#
# CPSC 323 Parser Project
# Authors: Ariadne Rincon, Lea Albano, Desiree Gomez
# Your task is to implement a parser using the default grammar 
# parser csv table generated by the Java program.
#
import csv
from turtle import st
import pandas as pd
from ast import parse


class Parser:
    """
    This class parses the token stream outputted from the lexical analyzer 
    into a parse tree or produces errors if the program is malformed.
    """
    def __init__(self, token_stream, parse_table_file):
        """
        Class constructor takes the token stream output from the 
        lexical analyzer as input. Appends $ to the end of the stream.
        """
        self.token_stream = token_stream
        self.parser_table = self.__read_parse_table(parse_table_file)
        # Append the end of file symbol to the end.
        self.token_stream.append(("$", "$"))
        # Creates empty stack
        self.stack = []
        # Prints current stack
        stackContent = self.token_stream
        print(stackContent)

    def __read_parse_table(self, parse_table_file):
        """
        Reads the parse table from a file.
        @param parse_table_file The file path for the parse table csv file.
        @return A dictionary/map (state, symbol) -> action/goto.
        """
        #Professor Psudocode from proj. document
        # Driver:
        # Place $ at the end of the input string 
        file = open('code.txt')
        fileContents = file.read()
        print("file contents: ", fileContents)
        for lines in file:      
            lines.append("$")
                
        # Push state 0 onto the stack  
        self.token_stream.append("0") 
        # Prints current stack
        stackContent = self.token_stream 
        print(stackContent)
        
        # Repeat
        # Let qm be the current state (TOS state) and  i the token
        with open("grammar.txt") as file_in:
            line = []
            tempProductionRulesArray = []
            for lines in file_in:
                line.append(lines)

        return tempProductionRulesArray       
     #raise NotImplementedError()

    def __has_next_token(self):
        """
        @return True if the token stream is not empty.
        """
        return len(self.token_stream) != 0

    def __get_next_token(self):
        """
        Fetches and consumes the next token in the input.
        @return tuple (token, type)
        """
        if self.__has_next_token():
            to_return = self.token_stream[0]
            self.token_stream.pop(0)
            return to_return
        return None

    def parse(self):
        self.parse_table_file = 'code.txt'
        productionRulesArray = self.__read_parse_table(self.parse_table_file)
        file = open('code.txt')
        fileContents = file.read()
        while (fileContents != ( "ACCT" or " " )): #loops until accepting state or error    
            qm = 0 #row name
            i = fileContents.split(' ') #column
        # Find   x = Table [Qm, i];
            tableLookup = pd.read_csv('parsetable.csv')
            x = tableLookup.at[qm, i] 
            print(x)
            #print(qm, " , ", i , " -> ",x )

        # Case x of
        # S(Qn) : Push (i) and enter qn, i.e., push (Qn);
        
            if (x[0] == "S"):
                self.token_stream.append(i) #push(i)
                self.token_stream.append(x[1]) #push number after S
                # Prints current stack
                stackContent = self.token_stream 
                print(stackContent)
                
        #  R(n): Reduce by production #n by popping  2x # of RHS symbols
            if (x[0] == "R"):
                productionRuleNum = x[1] - 1
                productionRule = productionRulesArray[productionRuleNum] 
                #example: productionRule = E -> id
        #  Let Qj be the TOS state
        #  Push  the LHS  L onto the stack
                if(productionRuleNum == (0 | 2)): #If production rule 1 or 3
                    self.token_stream.pop(6)
                    # Prints current stack
                    stackContent = self.token_stream 
                    print(stackContent)
                    stackQuantity = self.token_stream.len()
                    Qj = self.token_stream[stackQuantity - 1] #Gets TOS after popping
                    if (productionRuleNum == 0):
                        self.token_stream("S")
                        # Prints current stack
                        stackContent = self.token_stream 
                        print(stackContent)
                    elif (productionRuleNum == 2):
                        self.token_stream.append("E")
                        # Prints current stack
                        stackContent = self.token_stream 
                        print(stackContent)
                elif ((productionRuleNum) == (1 | 3)): #If production rule 2 or 4
                    self.token_stream.pop(2)
                    # Prints current stack
                    stackContent = self.token_stream 
                    print(stackContent)
                    stackQuantity = self.token_stream.len()
                    Qj = self.token_stream[stackQuantity - 1] #Gets TOS after popping
                    if(productionRuleNum == 1):
                        self.token_stream.append("S")
                        # Prints current stack
                        stackContent = self.token_stream 
                        print(stackContent)
                    elif (productionRuleNum == 3):
                        self.token_stream.append("E")
                        # Prints current stack
                        stackContent = self.token_stream 
                        print(stackContent)
                
                L = self.self[stackQuantity - 1]

        #  Push Qk = Table [Qj, L] onto the stack
                Qk = tableLookup.at[Qj, L]
                self.token_stream.append(Qk)
                # Prints current stack
                stackContent = self.token_stream
                print(stackContent)
        # ACCT: Parsing is complete
        # Empty:  error condition
        # Until  ACCT or Error
        # Error Message
        if (fileContents == " "):
            print("Error Message: Input is an empty string.")
        print(self.__get_next_token())
        #raise NotImplementedError()